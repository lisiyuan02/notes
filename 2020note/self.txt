2020.10.26

self只能在函数内部使用，属性前面加self.表明该属性是实例属性，在该类中可以全局访问，
但是只有先在__init__初始化之后才能被实例直接访问，如果方法中直接定义属性，则为局部属性，只能被该方法引用。
在类中定义的属性是类属性，不会跟着实例的变化而变化。
所有加了self的变量，需要确保在构造函数init中出现，否则该变量也不是成员变量。

eg:
class Car:
    def __init__(self):
        self.a = 11
        self.b = 22
        self.show()
    def show(self):
        c = 33
        self.d = 44

ls = list()
for i in range(3):
    ls.append(Car()) #定义了三个实例化对象

print(ls[0].a)
print(ls[0].b)
#print(ls[0].show())
print(ls[0].d)

python中的类变量和C++中的静态变量不同：
	对象的内存中包含了成员变量（例如，self.xx），不同的对象占用不同的内存，这使得不同对象的成员变量相互独立，
	它们的值不受其他对象的影响对于成员变量。C++的类中的静态变量只被分配了一份内存，所有对象都是使用该内存中的数据，
	因此任意对象修改了该变量，都会影响到其他变量。而python中的类变量则不同，它并不是由类的所有对象共享，
	因此tmp修改了var1的值，并不影响其他对象（tmp2）以及类本身；只有类本身才能修改类变量的值，
	当一个对象被构造时(tmp2)，则将当前类变量的值拷贝给该对象。



